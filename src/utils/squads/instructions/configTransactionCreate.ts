/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getConfigActionDecoder,
  getConfigActionEncoder,
  type ConfigAction,
  type ConfigActionArgs,
} from '../types';

export const CONFIG_TRANSACTION_CREATE_DISCRIMINATOR = new Uint8Array([
  155, 236, 87, 228, 137, 75, 81, 39,
]);

export function getConfigTransactionCreateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CONFIG_TRANSACTION_CREATE_DISCRIMINATOR
  );
}

export type ConfigTransactionCreateInstruction<
  TProgram extends string = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
  TAccountMultisig extends string | AccountMeta<string> = string,
  TAccountTransaction extends string | AccountMeta<string> = string,
  TAccountCreator extends string | AccountMeta<string> = string,
  TAccountRentPayer extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountMultisig extends string
        ? WritableAccount<TAccountMultisig>
        : TAccountMultisig,
      TAccountTransaction extends string
        ? WritableAccount<TAccountTransaction>
        : TAccountTransaction,
      TAccountCreator extends string
        ? ReadonlySignerAccount<TAccountCreator> &
            AccountSignerMeta<TAccountCreator>
        : TAccountCreator,
      TAccountRentPayer extends string
        ? WritableSignerAccount<TAccountRentPayer> &
            AccountSignerMeta<TAccountRentPayer>
        : TAccountRentPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type ConfigTransactionCreateInstructionData = {
  discriminator: ReadonlyUint8Array;
  actions: Array<ConfigAction>;
  memo: Option<string>;
};

export type ConfigTransactionCreateInstructionDataArgs = {
  actions: Array<ConfigActionArgs>;
  memo: OptionOrNullable<string>;
};

export function getConfigTransactionCreateInstructionDataEncoder(): Encoder<ConfigTransactionCreateInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['actions', getArrayEncoder(getConfigActionEncoder())],
      [
        'memo',
        getOptionEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
        ),
      ],
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIG_TRANSACTION_CREATE_DISCRIMINATOR,
    })
  );
}

export function getConfigTransactionCreateInstructionDataDecoder(): Decoder<ConfigTransactionCreateInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['actions', getArrayDecoder(getConfigActionDecoder())],
    [
      'memo',
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
  ]);
}

export function getConfigTransactionCreateInstructionDataCodec(): Codec<
  ConfigTransactionCreateInstructionDataArgs,
  ConfigTransactionCreateInstructionData
> {
  return combineCodec(
    getConfigTransactionCreateInstructionDataEncoder(),
    getConfigTransactionCreateInstructionDataDecoder()
  );
}

export type ConfigTransactionCreateInput<
  TAccountMultisig extends string = string,
  TAccountTransaction extends string = string,
  TAccountCreator extends string = string,
  TAccountRentPayer extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  multisig: Address<TAccountMultisig>;
  transaction: Address<TAccountTransaction>;
  /** The member of the multisig that is creating the transaction. */
  creator: TransactionSigner<TAccountCreator>;
  /** The payer for the transaction account rent. */
  rentPayer: TransactionSigner<TAccountRentPayer>;
  systemProgram?: Address<TAccountSystemProgram>;
  actions: ConfigTransactionCreateInstructionDataArgs['actions'];
  memo: ConfigTransactionCreateInstructionDataArgs['memo'];
};

export function getConfigTransactionCreateInstruction<
  TAccountMultisig extends string,
  TAccountTransaction extends string,
  TAccountCreator extends string,
  TAccountRentPayer extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends
    Address = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
>(
  input: ConfigTransactionCreateInput<
    TAccountMultisig,
    TAccountTransaction,
    TAccountCreator,
    TAccountRentPayer,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): ConfigTransactionCreateInstruction<
  TProgramAddress,
  TAccountMultisig,
  TAccountTransaction,
  TAccountCreator,
  TAccountRentPayer,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    transaction: { value: input.transaction ?? null, isWritable: true },
    creator: { value: input.creator ?? null, isWritable: false },
    rentPayer: { value: input.rentPayer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.multisig),
      getAccountMeta(accounts.transaction),
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.rentPayer),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getConfigTransactionCreateInstructionDataEncoder().encode(
      args as ConfigTransactionCreateInstructionDataArgs
    ),
  } as ConfigTransactionCreateInstruction<
    TProgramAddress,
    TAccountMultisig,
    TAccountTransaction,
    TAccountCreator,
    TAccountRentPayer,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedConfigTransactionCreateInstruction<
  TProgram extends string = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    multisig: TAccountMetas[0];
    transaction: TAccountMetas[1];
    /** The member of the multisig that is creating the transaction. */
    creator: TAccountMetas[2];
    /** The payer for the transaction account rent. */
    rentPayer: TAccountMetas[3];
    systemProgram: TAccountMetas[4];
  };
  data: ConfigTransactionCreateInstructionData;
};

export function parseConfigTransactionCreateInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedConfigTransactionCreateInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 5) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount(),
      transaction: getNextAccount(),
      creator: getNextAccount(),
      rentPayer: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getConfigTransactionCreateInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
