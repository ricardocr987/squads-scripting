/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const SPENDING_LIMIT_USE_DISCRIMINATOR = new Uint8Array([
  16, 57, 130, 127, 193, 20, 155, 134,
]);

export function getSpendingLimitUseDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    SPENDING_LIMIT_USE_DISCRIMINATOR
  );
}

export type SpendingLimitUseInstruction<
  TProgram extends string = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
  TAccountMultisig extends string | AccountMeta<string> = string,
  TAccountMember extends string | AccountMeta<string> = string,
  TAccountSpendingLimit extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountDestination extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountVaultTokenAccount extends string | AccountMeta<string> = string,
  TAccountDestinationTokenAccount extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountMultisig extends string
        ? ReadonlyAccount<TAccountMultisig>
        : TAccountMultisig,
      TAccountMember extends string
        ? ReadonlySignerAccount<TAccountMember> &
            AccountSignerMeta<TAccountMember>
        : TAccountMember,
      TAccountSpendingLimit extends string
        ? WritableAccount<TAccountSpendingLimit>
        : TAccountSpendingLimit,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountDestination extends string
        ? WritableAccount<TAccountDestination>
        : TAccountDestination,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountMint extends string
        ? ReadonlyAccount<TAccountMint>
        : TAccountMint,
      TAccountVaultTokenAccount extends string
        ? WritableAccount<TAccountVaultTokenAccount>
        : TAccountVaultTokenAccount,
      TAccountDestinationTokenAccount extends string
        ? WritableAccount<TAccountDestinationTokenAccount>
        : TAccountDestinationTokenAccount,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type SpendingLimitUseInstructionData = {
  discriminator: ReadonlyUint8Array;
  /** Amount of tokens to transfer. */
  amount: bigint;
  /** Decimals of the token mint. Used for double-checking against incorrect order of magnitude of `amount`. */
  decimals: number;
  /** Memo used for indexing. */
  memo: Option<string>;
};

export type SpendingLimitUseInstructionDataArgs = {
  /** Amount of tokens to transfer. */
  amount: number | bigint;
  /** Decimals of the token mint. Used for double-checking against incorrect order of magnitude of `amount`. */
  decimals: number;
  /** Memo used for indexing. */
  memo: OptionOrNullable<string>;
};

export function getSpendingLimitUseInstructionDataEncoder(): Encoder<SpendingLimitUseInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['amount', getU64Encoder()],
      ['decimals', getU8Encoder()],
      [
        'memo',
        getOptionEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
        ),
      ],
    ]),
    (value) => ({ ...value, discriminator: SPENDING_LIMIT_USE_DISCRIMINATOR })
  );
}

export function getSpendingLimitUseInstructionDataDecoder(): Decoder<SpendingLimitUseInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['amount', getU64Decoder()],
    ['decimals', getU8Decoder()],
    [
      'memo',
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
  ]);
}

export function getSpendingLimitUseInstructionDataCodec(): Codec<
  SpendingLimitUseInstructionDataArgs,
  SpendingLimitUseInstructionData
> {
  return combineCodec(
    getSpendingLimitUseInstructionDataEncoder(),
    getSpendingLimitUseInstructionDataDecoder()
  );
}

export type SpendingLimitUseInput<
  TAccountMultisig extends string = string,
  TAccountMember extends string = string,
  TAccountSpendingLimit extends string = string,
  TAccountVault extends string = string,
  TAccountDestination extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountMint extends string = string,
  TAccountVaultTokenAccount extends string = string,
  TAccountDestinationTokenAccount extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  /** The multisig account the `spending_limit` is for. */
  multisig: Address<TAccountMultisig>;
  member: TransactionSigner<TAccountMember>;
  /** The SpendingLimit account to use. */
  spendingLimit: Address<TAccountSpendingLimit>;
  /** Multisig vault account to transfer tokens from. */
  vault: Address<TAccountVault>;
  /** Destination account to transfer tokens to. */
  destination: Address<TAccountDestination>;
  /** In case `spending_limit.mint` is SOL. */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The mint of the tokens to transfer in case `spending_limit.mint` is an SPL token. */
  mint?: Address<TAccountMint>;
  /** Multisig vault token account to transfer tokens from in case `spending_limit.mint` is an SPL token. */
  vaultTokenAccount?: Address<TAccountVaultTokenAccount>;
  /** Destination token account in case `spending_limit.mint` is an SPL token. */
  destinationTokenAccount?: Address<TAccountDestinationTokenAccount>;
  /** In case `spending_limit.mint` is an SPL token. */
  tokenProgram?: Address<TAccountTokenProgram>;
  amount: SpendingLimitUseInstructionDataArgs['amount'];
  decimals: SpendingLimitUseInstructionDataArgs['decimals'];
  memo: SpendingLimitUseInstructionDataArgs['memo'];
};

export function getSpendingLimitUseInstruction<
  TAccountMultisig extends string,
  TAccountMember extends string,
  TAccountSpendingLimit extends string,
  TAccountVault extends string,
  TAccountDestination extends string,
  TAccountSystemProgram extends string,
  TAccountMint extends string,
  TAccountVaultTokenAccount extends string,
  TAccountDestinationTokenAccount extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends
    Address = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
>(
  input: SpendingLimitUseInput<
    TAccountMultisig,
    TAccountMember,
    TAccountSpendingLimit,
    TAccountVault,
    TAccountDestination,
    TAccountSystemProgram,
    TAccountMint,
    TAccountVaultTokenAccount,
    TAccountDestinationTokenAccount,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): SpendingLimitUseInstruction<
  TProgramAddress,
  TAccountMultisig,
  TAccountMember,
  TAccountSpendingLimit,
  TAccountVault,
  TAccountDestination,
  TAccountSystemProgram,
  TAccountMint,
  TAccountVaultTokenAccount,
  TAccountDestinationTokenAccount,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: false },
    member: { value: input.member ?? null, isWritable: false },
    spendingLimit: { value: input.spendingLimit ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    vaultTokenAccount: {
      value: input.vaultTokenAccount ?? null,
      isWritable: true,
    },
    destinationTokenAccount: {
      value: input.destinationTokenAccount ?? null,
      isWritable: true,
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.multisig),
      getAccountMeta(accounts.member),
      getAccountMeta(accounts.spendingLimit),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.vaultTokenAccount),
      getAccountMeta(accounts.destinationTokenAccount),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getSpendingLimitUseInstructionDataEncoder().encode(
      args as SpendingLimitUseInstructionDataArgs
    ),
  } as SpendingLimitUseInstruction<
    TProgramAddress,
    TAccountMultisig,
    TAccountMember,
    TAccountSpendingLimit,
    TAccountVault,
    TAccountDestination,
    TAccountSystemProgram,
    TAccountMint,
    TAccountVaultTokenAccount,
    TAccountDestinationTokenAccount,
    TAccountTokenProgram
  >;

  return instruction;
}

export type ParsedSpendingLimitUseInstruction<
  TProgram extends string = typeof SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The multisig account the `spending_limit` is for. */
    multisig: TAccountMetas[0];
    member: TAccountMetas[1];
    /** The SpendingLimit account to use. */
    spendingLimit: TAccountMetas[2];
    /** Multisig vault account to transfer tokens from. */
    vault: TAccountMetas[3];
    /** Destination account to transfer tokens to. */
    destination: TAccountMetas[4];
    /** In case `spending_limit.mint` is SOL. */
    systemProgram?: TAccountMetas[5] | undefined;
    /** The mint of the tokens to transfer in case `spending_limit.mint` is an SPL token. */
    mint?: TAccountMetas[6] | undefined;
    /** Multisig vault token account to transfer tokens from in case `spending_limit.mint` is an SPL token. */
    vaultTokenAccount?: TAccountMetas[7] | undefined;
    /** Destination token account in case `spending_limit.mint` is an SPL token. */
    destinationTokenAccount?: TAccountMetas[8] | undefined;
    /** In case `spending_limit.mint` is an SPL token. */
    tokenProgram?: TAccountMetas[9] | undefined;
  };
  data: SpendingLimitUseInstructionData;
};

export function parseSpendingLimitUseInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedSpendingLimitUseInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === SQUADS_MULTISIG_PROGRAM_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount(),
      member: getNextAccount(),
      spendingLimit: getNextAccount(),
      vault: getNextAccount(),
      destination: getNextAccount(),
      systemProgram: getNextOptionalAccount(),
      mint: getNextOptionalAccount(),
      vaultTokenAccount: getNextOptionalAccount(),
      destinationTokenAccount: getNextOptionalAccount(),
      tokenProgram: getNextOptionalAccount(),
    },
    data: getSpendingLimitUseInstructionDataDecoder().decode(instruction.data),
  };
}
